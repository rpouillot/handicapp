{
    "collab_server" : "",
    "contents" : "shinyServer <- function(input, output, session) {\n  \n  # Reactive expression for the data subsetted to what the user selected\n  filteredData <- reactive({\n    if(input$Auditif + input$Moteur + input$Visuel+ input$Mental == 0) return(NULL) \n    if(input$Auditif) dataH <- subset(dataH, as.logical(auditif))\n    if(input$Moteur) dataH <- subset(dataH, as.logical(moteur))\n    if(input$Visuel) dataH <- subset(dataH, as.logical(visuel))\n    if(input$Mental) dataH <- subset(dataH, as.logical(mental))\n    dataH <- subset(dataH, ACTIVITE %in% input$activite)\n    return(dataH)\n  })\n  \n  output$map <- renderLeaflet({\n    # Use leaflet() here, and only include aspects of the map that\n    # won't need to change dynamically (at least, not unless the\n    # entire map is being torn down and recreated).\n    leaflet() %>% \n      addProviderTiles(providers$OpenStreetMap.Mapnik, #providers$Stamen.TonerLite,\n                       options = providerTileOptions(noWrap = TRUE)) %>%\n        fitBounds(-4.6, 42.5, 7.84, 51.01) #limite France metro\n  })\n  \n  # A reactive expression that returns the set of adress that are\n  # in bounds right now\n  dataInBounds <- reactive({\n    if(is.null(input$map_bounds) || is.null(filteredData())) return(dataH[FALSE,])\n    bounds <- input$map_bounds\n    latRng <- range(bounds$north, bounds$south)\n    lngRng <- range(bounds$east, bounds$west)\n    \n    return(subset(filteredData(),\n           lat >= latRng[1] & lat <= latRng[2] &\n             long >= lngRng[1] & long <= lngRng[2]))\n  })\n  \n  \n  # Incremental changes to the map (in this case, replacing the\n  # circles when a new color is chosen) should be performed in\n  # an observer. Each independent set of things that can change\n  # should be managed in its own observer.\n    observe({\n      if(is.null(filteredData())) {\n         leafletProxy(\"map\", data = filteredData() ) %>% clearMarkers()\n           } else {\n            leafletProxy(\"map\", data = filteredData() ) %>%\n          clearMarkers() %>%\n          addMarkers(layerId=filteredData()$index)\n           }\n    })\n  \n    \n    observe({\n      leafletProxy(\"map\") %>% clearPopups()\n      event <- input$map_marker_click\n      if (is.null(event)) return()\n      \n      isolate({\n        showPopup(event$id, event$lat, event$lng)\n      })\n    })\n\n\n    showPopup <- function(ident, lat, lng) {\n      selectedMark <- subset(filteredData(), index == ident)\n      content <- paste0(\n        \"<h5>\", selectedMark$ETABLISSEMENT, \"</h5>\",\n        \"<h6>\", selectedMark$ACTIVITE, \"</h6>\",\n        selectedMark$formatted_address,\"<br>\",\n        \"Tel:\",selectedMark$TELEPHONE,\"<br>\",\n        \"Contact: <a mailto:\",selectedMark$EMAILCONTACT,\">\",selectedMark$EMAILCONTACT,\"</a><br>\",\n        \"Site Web: <a href=\",selectedMark$SITEWEB,\">\",selectedMark$SITEWEB, \"</a>\"\n      # )\n      )\n      leafletProxy(\"map\") %>% addPopups(lng, lat, content, layerId = ident)\n    }\n    \n    \n  Nb <- reactive(nrow(dataInBounds()))\n  \n  output$TableSelection <- renderDT({\n    validate(\n      need(Nb() != 0, \"Aucun établissement sélectionné\"),\n      need(Nb() <= 100,\"Trop d'établissements sélectionnés (>100). Zoomez sur la carte\" )\n    )\n    return(subset(dataInBounds(),\n                  select= c(\"ETABLISSEMENT\",\"ACTIVITE\",\"CONTACT\",\"Courriel\",\"Site\",\"TELEPHONE\",        \n                            \"FAX\",\"ADRESSE\",\"CODEPOSTAL\",\"VILLE\",\"DEPARTEMENT\",\"RESEAU\"\n                            ))\n    )\n    },escape=FALSE)\n    \n  output$NbRecords <- renderText(\n    return(Nb())\n  )\n}\n",
    "created" : 1523898502785.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "559603337",
    "id" : "3B6B842A",
    "lastKnownWriteTime" : 1523912625,
    "last_content_update" : 1523912625798,
    "path" : "~/Handicapp/server.R",
    "project_path" : "server.R",
    "properties" : {
    },
    "relative_order" : 2,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}